const builder=e=>{let t,s,o,n,c;e=e.promise||e;let a=0;let l,r=0,i=0;let u,m=0;let d=0;const f=(t,n,c,p)=>{(async t=>!r||m<r?(r&&(m++,setTimeout(()=>{m--,u=null},i)),u=e(...t)):o?u:Promise.reject({code:429,message:"Too many requests",value:await u}))(t).then(e=>{a&&(l=e,setTimeout(()=>l=null,a)),s=null,n(e)}).catch(e=>{p<d?f(t,n,c,p+1):(s=null,c(e))})};let p=0;let h;const y={promise:async(...e)=>{if(l)return l;let o,a;return t=new Promise((e,t)=>{o=e,a=t}),s?c?o(s):a({code:102,message:"Async request already in progress",value:await s}):((e,o,c)=>{if(p){const a=t;h=t,setTimeout(async()=>{h!==a?n?o(h):c({code:409,message:"Async request be debounced",value:await h}):(h=null,s=a,f(e,o,c,0))},p)}else s=t,f(e,o,c,0)})(e,o,a),t},allow:(...e)=>(o=e.includes(429),n=e.includes(409),c=e.includes(102),y),cache:e=>(a=e,y),debounce:e=>(p=e,y),retries:e=>(d=e,y),throttle:(e,t)=>(r=e,i=t,y)};return y},dag=()=>{const e=new Map,t=e=>"function"==typeof e,s=async(e,o,n,c,a,l,r)=>{(l.length?r(...await Promise.all(l)):r()).then(i=>{n.set(l,i),++a[0]===n.size&&e(Promise.all([...n.values()]));const u=c.get(r);if(u)for(const l of u)l[l.indexOf(r)]=i,l.every(e=>!t(e))&&s(e,o,n,c,a,l,n.get(l)).catch(e=>o(e))}).catch(e=>o(e))},o={promise:()=>new Promise((o,n)=>{const c=new Map,a=new Map;for(const[s,o]of e){const e=[...s];c.set(e,o);for(const s of e)t(s)&&(a.has(s)?a.get(s).push(e):a.set(s,[e]))}const l=[0];for(const[e,r]of c)e.every(e=>!t(e))&&s(o,n,c,a,l,e,r).catch(e=>n(e))}),add:(t,...s)=>(e.set(s.map(e=>e.promise||e),t.promise||t),o)};return o};export{builder,dag};